use crate::plan::ActionPlan;
use crate::resolve::PlanningContext;
use std::collections::HashMap;
use std::sync::Arc;

/// Trait that all tool adapters must implement.
pub trait ToolAdapter: Send + Sync {
    /// Unique identifier for the tool.
    fn id(&self) -> String;

    /// Produces an ActionPlan based on the resolved configuration.
    fn plan(&self, ctx: &PlanningContext) -> crate::Result<ActionPlan>;
}

/// A registration entry for a tool adapter, used by the `inventory` crate.
pub struct AdapterRegistration {
    pub factory: fn() -> Arc<dyn ToolAdapter>,
}

inventory::collect!(AdapterRegistration);

/// A registry that holds and manages tool adapters.
pub struct ToolRegistry {
    adapters: HashMap<String, Arc<dyn ToolAdapter>>,
}

impl ToolRegistry {
    /// Creates a new, empty registry.
    pub fn new() -> Self {
        Self {
            adapters: HashMap::new(),
        }
    }

    /// Registers an adapter manually.
    pub fn register(&mut self, adapter: Arc<dyn ToolAdapter>) {
        self.adapters.insert(adapter.id(), adapter);
    }

    /// Gets an adapter by its ID.
    pub fn get(&self, id: &str) -> Option<Arc<dyn ToolAdapter>> {
        self.adapters.get(id).cloned()
    }

    /// Lists all registered adapter IDs, sorted alphabetically.
    pub fn list_ids(&self) -> Vec<String> {
        let mut ids: Vec<String> = self.adapters.keys().cloned().collect();
        ids.sort();
        ids
    }

    /// Returns a registry populated with all adapters registered via `inventory`.
    ///
    /// Note: For this to work with statically linked crates, the crates must be
    /// referenced somewhere in the binary to prevent the linker from stripping them.
    pub fn from_inventory() -> Self {
        let mut registry = Self::new();
        for registration in inventory::iter::<AdapterRegistration> {
            registry.register((registration.factory)());
        }
        registry
    }

    /// Alias for `from_inventory` to maintain backward compatibility where needed,
    /// but preferred use is `from_inventory()`.
    pub fn default_registry() -> Self {
        Self::from_inventory()
    }
}

impl Default for ToolRegistry {
    fn default() -> Self {
        Self::from_inventory()
    }
}

/// A dummy adapter for testing and M0 requirements.
pub struct TestAdapter;

inventory::submit! {
    AdapterRegistration {
        factory: || Arc::new(TestAdapter)
    }
}

impl ToolAdapter for TestAdapter {
    fn id(&self) -> String {
        "test".to_string()
    }

    fn plan(&self, ctx: &PlanningContext) -> crate::Result<ActionPlan> {
        let mut plan = ActionPlan::new();

        plan.add_action(crate::plan::Action::WriteFile {
            path: "MACC_GENERATED.txt".to_string(),
            content:
                "This is a test file generated by MACC.\nDeterministic content for verification.\n"
                    .as_bytes()
                    .to_vec(),
            scope: crate::plan::Scope::Project,
        });

        plan.add_action(crate::plan::Action::WriteFile {
            path: ".macc/test-output.json".to_string(),
            content: r#"{ 
  "status": "success",
  "adapter": "test",
  "purpose": "integration-testing",
  "api_key": "YOUR_API_KEY_HERE"
}
"#
            .as_bytes()
            .to_vec(),
            scope: crate::plan::Scope::Project,
        });

        plan.add_action(crate::plan::Action::WriteFile {
            path: ".env.example".to_string(),
            content: "DATABASE_URL=${DATABASE_URL}\nSTRIPE_KEY=REPLACE_ME\n"
                .as_bytes()
                .to_vec(),
            scope: crate::plan::Scope::Project,
        });

        if let Some(content) = crate::mcp_json::render_project_mcp_json(ctx.resolved) {
            plan.add_action(crate::plan::Action::WriteFile {
                path: ".mcp.json".to_string(),
                content: content.into_bytes(),
                scope: crate::plan::Scope::Project,
            });
        }

        Ok(plan)
    }
}

/// A mock adapter that returns a pre-defined plan, useful for UI testing.
pub struct MockAdapter {
    pub id: String,
    pub plan: ActionPlan,
}

impl ToolAdapter for MockAdapter {
    fn id(&self) -> String {
        self.id.clone()
    }

    fn plan(&self, _ctx: &PlanningContext) -> crate::Result<ActionPlan> {
        Ok(self.plan.clone())
    }
}
